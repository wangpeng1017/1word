import { PrismaClient } from '@prisma/client'
import * as fs from 'fs'
import * as path from 'path'

const prisma = new PrismaClient()

async function main() {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)
  const backupDir = path.join(process.cwd(), 'backups')
  
  if (!fs.existsSync(backupDir)) {
    fs.mkdirSync(backupDir, { recursive: true })
  }

  console.log('ðŸ”„ å¼€å§‹æ•°æ®è¿ç§»å‡†å¤‡...\n')

  try {
    // ä½¿ç”¨åŽŸå§‹ SQL æŸ¥è¯¢ç»•è¿‡ Prisma Client çš„ç±»åž‹æ£€æŸ¥
    const students: any[] = await prisma.$queryRaw`
      SELECT s.*, u.name as user_name, c.name as class_name
      FROM students s
      LEFT JOIN users u ON s.user_id = u.id
      LEFT JOIN classes c ON s.class_id = c.id
    `

    const studyPlans: any[] = await prisma.$queryRaw`SELECT COUNT(*) as count FROM study_plans`
    const classes: any[] = await prisma.$queryRaw`SELECT * FROM classes`

    console.log('ðŸ“¦ æ­¥éª¤ 1/5: å¤‡ä»½çŽ°æœ‰æ•°æ®...')
    
    const backup = {
      timestamp,
      students: students.map(s => ({
        id: s.id,
        user_id: s.user_id,
        student_no: s.student_no,
        class_id: s.class_id,
        grade: s.grade,
        user_name: s.user_name,
        class_name: s.class_name,
      })),
      studyPlans: String(studyPlans[0].count),
      classes: classes.length,
    }

    const backupFile = path.join(backupDir, `backup-${timestamp}.json`)
    fs.writeFileSync(backupFile, JSON.stringify(backup, null, 2))
    
    console.log(`âœ… å¤‡ä»½å®Œæˆ: ${backupFile}`)
    console.log(`   - å­¦ç”Ÿæ•°: ${students.length}`)
    console.log(`   - å­¦ä¹ è®¡åˆ’æ•°: ${String(studyPlans[0].count)}`)
    console.log(`   - ç­çº§æ•°: ${classes.length}\n`)

    // æ£€æŸ¥éœ€è¦è¿ç§»çš„æ•°æ®
    console.log('ðŸ” æ­¥éª¤ 2/5: æ£€æŸ¥å¾…è¿ç§»æ•°æ®...')
    
    const studentsWithoutClass = students.filter(s => !s.class_id || !s.grade)
    
    console.log(`   - éœ€è¦åˆ†é…ç­çº§çš„å­¦ç”Ÿ: ${studentsWithoutClass.length}`)
    
    if (studentsWithoutClass.length === 0) {
      console.log('âœ… æ‰€æœ‰å­¦ç”Ÿéƒ½å·²åˆ†é…ç­çº§\n')
      console.log('ðŸ“‹ ä¸‹ä¸€æ­¥: æ‰§è¡Œ npx prisma db push')
      return
    }

    // èŽ·å–æˆ–åˆ›å»ºé»˜è®¤ç­çº§
    console.log('\nðŸ« æ­¥éª¤ 3/5: å‡†å¤‡é»˜è®¤ç­çº§...')
    
    let defaultClass = classes.find(c => c.name === 'æœªåˆ†é…ç­çº§')

    if (!defaultClass) {
      // èŽ·å–ç¬¬ä¸€ä¸ªæ•™å¸ˆ
      const teachers: any[] = await prisma.$queryRaw`SELECT * FROM teachers LIMIT 1`
      
      if (teachers.length === 0) {
        console.log('   - åˆ›å»ºé»˜è®¤æ•™å¸ˆå’Œç­çº§...')
        
        // åˆ›å»ºé»˜è®¤æ•™å¸ˆç”¨æˆ·
        const adminEmail = 'admin@default.com'
        const existingAdmin: any[] = await prisma.$queryRaw`
          SELECT * FROM users WHERE email = ${adminEmail}
        `

        let adminUserId = existingAdmin[0]?.id

        if (!adminUserId) {
          const newUser: any[] = await prisma.$queryRaw`
            INSERT INTO users (id, email, password, name, role, is_active, created_at, updated_at)
            VALUES (gen_random_uuid(), ${adminEmail}, '$2a$10$temp', 'ç³»ç»Ÿç®¡ç†å‘˜', 'TEACHER', true, NOW(), NOW())
            RETURNING id
          `
          adminUserId = newUser[0].id
        }

        // åˆ›å»ºæ•™å¸ˆ
        const newTeacher: any[] = await prisma.$queryRaw`
          INSERT INTO teachers (id, user_id, school, subject, created_at, updated_at)
          VALUES (gen_random_uuid(), ${adminUserId}, 'é»˜è®¤å­¦æ ¡', 'è‹±è¯­', NOW(), NOW())
          RETURNING id
        `
        
        const teacherId = newTeacher[0].id

        // åˆ›å»ºé»˜è®¤ç­çº§
        const newClass: any[] = await prisma.$queryRaw`
          INSERT INTO classes (id, name, grade, teacher_id, is_active, created_at, updated_at)
          VALUES (gen_random_uuid(), 'æœªåˆ†é…ç­çº§', 'å¾…åˆ†é…', ${teacherId}, true, NOW(), NOW())
          RETURNING *
        `
        
        defaultClass = newClass[0]
        console.log('   âœ… é»˜è®¤æ•™å¸ˆå’Œç­çº§åˆ›å»ºæˆåŠŸ')
      } else {
        const teacherId = teachers[0].id
        
        const newClass: any[] = await prisma.$queryRaw`
          INSERT INTO classes (id, name, grade, teacher_id, is_active, created_at, updated_at)
          VALUES (gen_random_uuid(), 'æœªåˆ†é…ç­çº§', 'å¾…åˆ†é…', ${teacherId}, true, NOW(), NOW())
          RETURNING *
        `
        
        defaultClass = newClass[0]
        console.log('   âœ… é»˜è®¤ç­çº§åˆ›å»ºæˆåŠŸ')
      }
    } else {
      console.log('   âœ… é»˜è®¤ç­çº§å·²å­˜åœ¨')
    }

    // è¿ç§»å­¦ç”Ÿæ•°æ®
    console.log('\nðŸ‘¥ æ­¥éª¤ 4/5: è¿ç§»å­¦ç”Ÿæ•°æ®...')
    
    let migratedCount = 0
    const migrationLog: any[] = []

    for (const student of studentsWithoutClass) {
      try {
        await prisma.$executeRaw`
          UPDATE students
          SET class_id = ${defaultClass.id}, grade = ${defaultClass.grade}, updated_at = NOW()
          WHERE id = ${student.id}
        `

        migratedCount++
        migrationLog.push({
          student_no: student.student_no,
          name: student.user_name,
          old_class_id: student.class_id,
          old_grade: student.grade,
          new_class_id: defaultClass.id,
          new_grade: defaultClass.grade,
          status: 'success',
        })

        console.log(`   âœ… ${student.user_name} (${student.student_no}) -> æœªåˆ†é…ç­çº§`)
      } catch (error: any) {
        migrationLog.push({
          student_no: student.student_no,
          name: student.user_name,
          status: 'failed',
          error: error.message,
        })
        console.log(`   âŒ ${student.user_name} è¿ç§»å¤±è´¥: ${error.message}`)
      }
    }

    const migrationLogFile = path.join(backupDir, `migration-log-${timestamp}.json`)
    fs.writeFileSync(migrationLogFile, JSON.stringify(migrationLog, null, 2))

    console.log(`\nâœ… è¿ç§»å®Œæˆï¼`)
    console.log(`   - æˆåŠŸè¿ç§»: ${migratedCount} ä¸ªå­¦ç”Ÿ`)
    console.log(`   - è¿ç§»æ—¥å¿—: ${migrationLogFile}\n`)

    console.log('âš ï¸  é‡è¦æé†’ï¼š')
    console.log('   1. æ‰€æœ‰æœªåˆ†é…ç­çº§çš„å­¦ç”Ÿå·²ç§»è‡³ "æœªåˆ†é…ç­çº§"')
    console.log('   2. è¯·ç™»å½•ç®¡ç†åŽå°ä¸ºè¿™äº›å­¦ç”Ÿæ‰‹åŠ¨åˆ†é…æ­£ç¡®çš„ç­çº§\n')

    console.log('ðŸ“‹ æ­¥éª¤ 5/5: ä¸‹ä¸€æ­¥æ“ä½œ')
    console.log('   1. æ‰§è¡Œ: npx prisma generate')
    console.log('   2. æ‰§è¡Œ: npx prisma db push')
    console.log('   3. æ‰§è¡Œ: npm run build\n')

  } catch (error: any) {
    console.error('âŒ è¿ç§»å¤±è´¥:', error.message)
    console.error(error)
    process.exit(1)
  }
}

main()
  .catch((e) => {
    console.error('ä¸¥é‡é”™è¯¯:', e)
    process.exit(1)
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
